@startuml 2d_srpg_class
title 2DSRPG クラス図

left to right direction

enum TileType {
    GRASS = 1
    THICKET = 2
    FOREST = 3
    SAND = 4
    WATER = 5
    WALL = 6

    CASTLE_LEFT_TOP = 101
    CASTLE_RIGHT_TOP = 102
    CASTLE_LEFT_BOTTOM = 103
    CASTLE_RIGHT_BUTTON = 104

    CITY_LEFT = 111
    CITY_RIGHT = 112
}

enum ItemTargetType {
    MYSELF
    UNIT
    TILE
}

interface ISavaToJson {
    ..JSON形式での保存・読み込みを規定するインターフェース..
    -SaveManager save_manager;
    +abstract SaveData(): void;
    +abstract LoadData(string json_text): void;
}

class SoSaveDataHolder {
    ..セーブデータをまとめて保持するScriptableObject..
    +List<AllyUnitSaveData> {get; private set;}
}

class SaveManager {
    ..任意のデータをJSON形式で保存・読み込みする管理クラス..
    +SaveToJson(T save_data, string file_path): void
    +LoadFromJson(string file_path): void
}

class SoStore {
    ..IDに対応したScriptableObjectを管理し提供するストア..
    +List<IdSOPair> id_so_list {get; private set;}
    +Dictionary<string, ScriptableObject> id_so_pairs {get; private set;} 

    +GetSO(string id): ScriptableObject;
    +GetSO<T>(string id): T
}

struct IdSOPair {
    +string id {get; private set;}
    +ScriptableObject so {get; private set;}
}

SoStore +-- IdSOPair

abstract ItemSO {
    +string id {get; private set;}
    +string name {get; private set;}
    +bool priceless {get; private set;}
    +int sale_price {get; private set;}
    +int buying_price {get; private set;}
    +int max_available_count {get; private set;}
    +Sprite icon {get; private set;}
    +ItemTargetType target_type {get; private set;}
}

abstract Item {
    +int avalilable_count {get; private set;}
    +ItemSO item_data;
    +abstract Use(object targets): void

    +Item(ItemSO item_so): void
}

ItemSO +-- ItemTargetType

class WeaponTypeAffinity {
    +Dictionary<WeaponType, List<WeaponType>> strongAgainst
    +Dictionary<WeaponType, List<WeaponType>> weakAgainst
    +IsStrongAgainst(attacker: WeaponType, defender: WeaponType): bool
    +IsWeakAgainst(attacker: WeaponType, defender: WeaponType): bool
}


class WeaponSO {
    +int[] ranges {get; private set;}
    +int power  {get; private set;}
    +WeaponType weapon_type {get; private set;}
    +WeaponCategory weapon_category {get; private set;}
}

class Weapon {
    +int available_count {get; private set;}
    +WeaponSO weapon_data; 
    +override Use(object targets): void
    +Weapon(WeponSO weapon_so): void
}

enum WeaponCategory {
    PHYSICAL
    MAGICAL
}

enum WeaponType {
    SWORD
    LANCE
    AXE
    REASON
    LIGHT
    DARK
}

Weapon +-- WeaponType
Weapon +-- WeaponCategory

enum ActionType {
    ATTACK
    HEAL
    WAIT
}

interface IUnitAction {
    ..ユニットの行動処理を規定するインターフェース..
    +ActionType action_type {get; private set;}
    +string action_name {get; protected set;}
    +CanExecute(Unit exec_unit, object target): bool
    +Execute(Unit exec_unit, object taraget): void
}

IUnitAction +-- ActionType
IUnitAction --> ActionType

class AttackAction {
}

class HealAction {
}

class WaitAction {
}

class Unit {
    +string name {get; private set;}
    +int curret_hp {get; private set;}
    +Vector2Int pos {get; private set;}
    +UnitStatus status {get; private set;}
    +UnitClassSO class {get; private set;}
    +bool is_alive {get; privaate set;}
    +bool is_selected {get; private set;}
    +bool has_moved {get; private set;}
    +Sprite icon {get; private set;}
    +Weapon equip_wepon {get; private set;}
    +List<Weapon> have_weapons {get; private set;}
    +List<Item> have_items {get; private set;}
    +List<IUnitAction> available_actions {get; private set;}
    +List<Tile> moveable_tiles {get; private set;}
    +List<Tile> in_range_tiles {get; private set;}

    +GridMove(Vector2 target_pos, Vector2Int target_grid_pos): void
    +virtual GetMoveableArea(Tile[,] tile_map, int map_width, int map_height): List<Vector2Int>
    +SearchMoveableArea(Tile[,] tile_map, int map_width, int map_height): void
    +SearchInRangeTiles(Tile[,] tile_map, int map_width, int map_height): void

    +Select(): void
    +DeSelect(): void
    +ResetTurnState(): void
    +TakeDamege(int amount): void
    +Heal(int amount): void
    +UpdateAvailableActions(): void
}

class AllyUnit {
    ..味方ユニットの具体的な操作・成長処理を持つクラス..
    +UnitGrowthRate growth_rate {get; private set;}
    +int exp {get; private set;}
    +GainExp(int exp_amount): void
    +LevelUp(): void
    +ClassPromote(): void
    +SaveData(): void;
    +LoadData(string json_text): void;
}

class EnemyUnit {
    ..敵ユニットの行動AIや移動処理を担当するクラス..
    +int base_exp_amount {get; private set;}
    +AIType ai_type {get; private set;}

    +override SearchMoveableArea(Tile[,] tile_map, int map_width, int map_height): void
    +MoveAgent(): void
}

struct AllyUnitSaveData {
    +int curret_hp {get; private set;}
    +int max_hp {get; private set;}
    +int str {get; private set;}
    +int m_power {get; private set;}
    +int tec {getl private set;}
    +int agi {get; private set;}
    +int def {get; private set;}
    +int m_def {get; private set;}
    +int luck {get; private set;}
    +int physique {get; private set;}
    +int level {get; private set;}
    +int exp {get; private set;}
    +string equip_wepon_id {get; private set;}
    +List<string> have_weapon_ids {get; private set;}
    +List<string> have_item_ids {get; private set;}
}

enum AIType {
    IDLE
    REACTIVE
    AGGRESSIVE
}

EnemyUnit +-- AIType

class UnitStatusSO {
    ..ユニットのステータス情報を保持するScriptableObject 初期データに使用..
    +int max_hp {get; private set;}
    +int str {get; private set;}
    +int m_power {get; private set;}
    +int tec {getl private set;}
    +int agi {get; private set;}
    +int def {get; private set;}
    +int m_def {get; private set;}
    +int luck {get; private set;}
    +int physique {get; private set;}
    +int level {get; private set;}
}

class UnitStatus {
    ..ユニットのステータス情報を保持するクラス(HPや攻撃力など)..
    +int max_hp {get; private set;}
    +int str {get; private set;}
    +int m_power {get; private set;}
    +int tec {getl private set;}
    +int agi {get; private set;}
    +int def {get; private set;}
    +int m_def {get; private set;}
    +int luck {get; private set;}
    +int physique {get; private set;}
    +int level {get; private set;}

    +UnitStatus(UnitStatusSO base_status): void
    +UnitStatus(int max_hp, int str, int m_power, int tec, int agi, int def, int m_def, int luck, int physique): void
}

note right of UnitStatus::UnitStatus
    ユニットの初期ステータスはSOの静的データステータスを使う
end note

note right of UnitStatus::UnitStatus
    セーブデータからのステータス読み込みはこのコンストラクタ
end note

class UnitGrowthRateSO {
    +int hp_rate {get; private set;}
    +int str_rate {get; private set;}
    +int m_power_rate {get; private set;}
    +int tec_rate {get; private set;}
    +int agi_rate {get; private set;}
    +int def_rate {get; private set;}
    +int m_def_rate {get; private set;}
    +int luck_rate {get; private set;}
    +int physique_rate {get; private set;}
}

class UnitClassSO {
    +string class_name
    +int move_cost {get; private set;}
    +Sprite icon {get; private set;}
    +List<WeaponType> usable_weapon_types { get; private set; }
}

class UnitUpperClassSO {

}

class UnitLowerClassSO {
    +UnitUpperClass promotable_class {get; private set;}
}

class UnitManager {
    ..全ユニットの操作・管理を行うクラス..
    +List<AllyUnit> ally_unit {get; private set;}
    +List<EnemyUnit> enemy_unit {get; private set;}
    +Unit selected_unit {get; private set;}
    -MapManager map_manager

    +SelectUnit(Unit select_unit): void
    +DeselectUnit(): void
    +ResetAllTurnStates(): void
    +UpdateMoveableArea(Tile[,] tile_map, int map_width, int map_height): void
    +UpdateRangeTiles(Tile[,] tile_map, int map_width, int map_height): void
}

class MapManager {
    ..マップのタイル配置や表示を管理するクラス..
    
    -MapInfo map_info
    -TileFactory tile_factory
    -CSVHandler csv_handler
    -Tile[,] map_tiles

    +ReadMapData(): int[,]
    +MapDisplay(): void
    +GetTileData(Vector2Int pos): Tile
    +UpdateMapData(Dictionary<Vector2Int, int>): void 
    +IsInBounds(Vector2Int pos): bool
    +RefreshMapDisplay(): void
    +HightRightTiles(List<Tile> tiles, Color color): void
    +ClearHightRights(): void
}

class MapSaveData {
    
}

class TileFactory {
    -TileTypePrefabPair[] tile_pairs
    -Dictionary<TileType, GameObject> tile_prefabs

    +InstantiateTile(TileType tile_type, Vector2 pos, Quaternion rotation): Tile
}

struct TileTypePrefabPair {
    +TileType type
    +GameObject prefab
}

TileFactory +-- TileTypePrefabPair

class MonoBehavior {

}

class ScriptableObject {

}

class CSVHandler {
    +async WriteCSV(string csv_file, List<string[]> write_data): WriteResult
    +async ReadCSV(string csv_file): ReadResult
}

struct ReadResult {
    +bool is_success
    +List<string[]> read_data
    +string error_message
}

struct WriteResult {
    +bool is_success
    +string error_message
}

CSVHandler +-- ReadResult
CSVHandler +-- WriteResult

class MapInfo {
    +string csv_file_name {get; private set;}
    +int width {get; private set;}
    +int height {get; private set;}
    +Vector2Int[] initial_pos_ally {get; private set;}
    +Vector2Int[] initial_pos_enemy {get; private set;}
}

abstract Tile {
    #TileType tile_type
    +string tile_name { get; protected set; }
    +int move_cost { get; protected set; }
    +int avo_increase { get; protected set; }
    +int hp_recover { get; protected set; }

    +GetCanMove(UnitClass unit_class): bool
} 

note right of Tile::GetCanMove
    引数のユニットクラスがタイルを移動可能かを返す
end note

class Grass {

}

class Thicket {

}

class Fortress {

}

class Catsle {

}

class Sand {

}

class Forest {

}

class Water {

}

class Wall{

}

AttackAction ..|> IUnitAction
HealAction ..|> IUnitAction
WaitAction ..|> IUnitAction

Item --|> ScriptableObject
Weapon --|> Item

Unit --|> MonoBehavior
Unit --> UnitClass
Unit --> Tile
Unit --> IUnitAction
Unit --> ItemInstance

UnitClass --|> ScriptableObject
UnitStatus --|> ScriptableObject
AllyUnit --|> Unit
AllyUnit ..|> ISavaToJson
AllyUnit --> UnitGrowthRate
EnemyUnit --|> Unit
UnitUpperClass --|> UnitClass
UnitLowerClass --|> UnitClass

UnitManager --> Unit
UnitManager --> MapManager
UnitManager --> Tile

MapManager --> CSVHandler
MapManager --> TileFactory
MapManager --> Tile

MapInfo --|> ScriptableObject

Tile --|> MonoBehavior
Grass --|> Tile
Thicket --|> Tile
Fortress --|> Tile
Catsle --|> Tile
Sand --|> Tile
Forest --|> Tile
Wall --|> Tile
Water --|> Tile


@enduml